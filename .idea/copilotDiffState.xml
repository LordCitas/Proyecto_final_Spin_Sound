<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Service/DiscogsService.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Service/DiscogsService.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use Psr\Log\LoggerInterface;&#10;use Symfony\Contracts\HttpClient\HttpClientInterface;&#10;&#10;class DiscogsService&#10;{&#10;    private const BASE_URL = 'https://api.discogs.com';&#10;&#10;    public function __construct(&#10;        private readonly HttpClientInterface $client,&#10;        private readonly string $token,&#10;        private readonly string $projectDir = '',&#10;        private readonly ?LoggerInterface $logger = null,&#10;    ) {}&#10;&#10;    /**&#10;     * Busca un release por artista + título y devuelve el primer resultado.&#10;     * Si se pasa un $discogsId busca directamente ese release.&#10;     */&#10;    public function getReleaseData(string $artista, string $titulo, ?int $discogsId = null): ?array&#10;    {&#10;        try {&#10;            if ($discogsId) {&#10;                return $this-&gt;fetchRelease($discogsId);&#10;            }&#10;&#10;            // 1) Buscar en el catálogo&#10;            $response = $this-&gt;client-&gt;request('GET', self::BASE_URL . '/database/search', [&#10;                'headers' =&gt; $this-&gt;headers(),&#10;                'query'   =&gt; [&#10;                    'artist' =&gt; $artista,&#10;                    'title'  =&gt; $titulo,&#10;                    'type'   =&gt; 'masters',&#10;                    'per_page' =&gt; 1,&#10;                ],&#10;            ]);&#10;&#10;            $data = $response-&gt;toArray();&#10;&#10;            if (empty($data['results'])) {&#10;                $this-&gt;logger?-&gt;debug('Discogs search returned no results', ['artist' =&gt; $artista, 'title' =&gt; $titulo]);&#10;                return null;&#10;            }&#10;&#10;            $releaseId = $data['results'][0]['id'];&#10;            return $this-&gt;fetchRelease($releaseId);&#10;&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger?-&gt;error('Error fetching release data from Discogs', ['exception' =&gt; $e-&gt;getMessage(), 'artist' =&gt; $artista, 'title' =&gt; $titulo, 'discogsId' =&gt; $discogsId]);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene los detalles completos de un release por su ID de Discogs.&#10;     */&#10;    public function fetchRelease(int $id, string $type = 'releases'): ?array&#10;    {&#10;        try {&#10;            $response = $this-&gt;client-&gt;request('GET', self::BASE_URL . '/' . $type . '/' . $id, [&#10;                'headers' =&gt; $this-&gt;headers(),&#10;            ]);&#10;&#10;            return $response-&gt;toArray();&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger?-&gt;error('Error fetching release from Discogs', ['exception' =&gt; $e-&gt;getMessage(), 'discogsId' =&gt; $id]);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extrae la URL de la imagen principal de un release.&#10;     * Prioriza 'primary' image, o la primera disponible.&#10;     */&#10;    public function getImageUrl(?array $releaseData): ?string&#10;    {&#10;        if (!$releaseData || empty($releaseData['images'])) {&#10;            $this-&gt;logger?-&gt;debug('No images found in release data', ['releaseData_keys' =&gt; $releaseData ? array_keys($releaseData) : null]);&#10;            return null;&#10;        }&#10;&#10;        // Buscar imagen primaria&#10;        foreach ($releaseData['images'] as $image) {&#10;            if (($image['type'] ?? '') === 'primary' &amp;&amp; !empty($image['uri'])) {&#10;                return $image['uri'];&#10;            }&#10;        }&#10;&#10;        // Si no hay primaria, devolver la primera imagen&#10;        $uri = $releaseData['images'][0]['uri'] ?? null;&#10;        if ($uri) {&#10;            return $uri;&#10;        }&#10;&#10;        $this-&gt;logger?-&gt;debug('Images array exists but no uri found', ['images' =&gt; $releaseData['images']]);&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Busca lanzamientos por texto libre (para el buscador general).&#10;     */&#10;    public function search(string $query, int $perPage = 20, int $page = 1): array&#10;    {&#10;        try {&#10;            $response = $this-&gt;client-&gt;request('GET', self::BASE_URL . '/database/search', [&#10;                'headers' =&gt; $this-&gt;headers(),&#10;                'query'   =&gt; [&#10;                    'q'        =&gt; $query,&#10;                    'type'     =&gt; 'release',&#10;                    'per_page' =&gt; $perPage,&#10;                    'page'     =&gt; $page,&#10;                ],&#10;            ]);&#10;&#10;            return $response-&gt;toArray();&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger?-&gt;error('Discogs search error', ['exception' =&gt; $e-&gt;getMessage(), 'query' =&gt; $query]);&#10;            return ['results' =&gt; [], 'pagination' =&gt; []];&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Descarga una imagen de Discogs y la guarda en public/img/vinilos/.&#10;     * Si ya existe el archivo local, no la vuelve a descargar.&#10;     * Devuelve la ruta relativa pública (ej: /img/vinilos/discogs_24047.jpeg) o null.&#10;     */&#10;    public function downloadImage(string $url, string $filename): ?string&#10;    {&#10;        $dir = $this-&gt;projectDir . '/public/img/vinilos/';&#10;&#10;        if (!is_dir($dir)) {&#10;            mkdir($dir, 0775, true);&#10;        }&#10;&#10;        $localPath = $dir . $filename;&#10;&#10;        // Si ya existe, no descargar de nuevo&#10;        if (file_exists($localPath)) {&#10;            return '/img/vinilos/' . $filename;&#10;        }&#10;&#10;        $context = stream_context_create([&#10;            'http' =&gt; [&#10;                'header'  =&gt; &quot;User-Agent: SpinSoundApp/1.0\r\nAuthorization: Discogs token=&quot; . $this-&gt;token . &quot;\r\n&quot;,&#10;                'timeout' =&gt; 15,&#10;            ],&#10;        ]);&#10;&#10;        $imageData = @file_get_contents($url, false, $context);&#10;&#10;        if ($imageData === false) {&#10;            $this-&gt;logger?-&gt;warning('No se pudo descargar la imagen', ['url' =&gt; $url]);&#10;            return null;&#10;        }&#10;&#10;        file_put_contents($localPath, $imageData);&#10;        $this-&gt;logger?-&gt;info('Imagen guardada localmente', ['path' =&gt; $localPath]);&#10;&#10;        return '/img/vinilos/' . $filename;&#10;    }&#10;&#10;    private function headers(): array&#10;    {&#10;        $headers = [&#10;            'User-Agent' =&gt; 'SpinSoundApp/1.0 +https://spinsound.com',&#10;        ];&#10;&#10;        if ($this-&gt;token) {&#10;            $headers['Authorization'] = 'Discogs token=' . $this-&gt;token;&#10;        } else {&#10;            $this-&gt;logger?-&gt;warning('Discogs token is empty. API requests may be rate-limited or blocked. Set DISCOGS_TOKEN in .env.');&#10;        }&#10;&#10;        return $headers;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;namespace App\Service;&#10;&#10;use Psr\Log\LoggerInterface;&#10;use Symfony\Contracts\HttpClient\HttpClientInterface;&#10;&#10;class DiscogsService&#10;{&#10;    private const BASE_URL = 'https://api.discogs.com';&#10;&#10;    public function __construct(&#10;        private readonly HttpClientInterface $client,&#10;        private readonly string $token,&#10;        private readonly string $projectDir = '',&#10;        private readonly ?LoggerInterface $logger = null,&#10;    ) {}&#10;&#10;    /**&#10;     * Busca un release por artista + título y devuelve el primer resultado.&#10;     * Si se pasa un $discogsId busca directamente ese release.&#10;     */&#10;    public function getReleaseData(string $artista, string $titulo, ?int $discogsId = null): ?array&#10;    {&#10;        try {&#10;            if ($discogsId) {&#10;                return $this-&gt;fetchRelease($discogsId);&#10;            }&#10;&#10;            // 1) Buscar en el catálogo&#10;            $response = $this-&gt;client-&gt;request('GET', self::BASE_URL . '/database/search', [&#10;                'headers' =&gt; $this-&gt;headers(),&#10;                'query'   =&gt; [&#10;                    'artist' =&gt; $artista,&#10;                    'title'  =&gt; $titulo,&#10;                    'type'   =&gt; 'masters',&#10;                    'per_page' =&gt; 1,&#10;                ],&#10;            ]);&#10;&#10;            $data = $response-&gt;toArray();&#10;&#10;            if (empty($data['results'])) {&#10;                $this-&gt;logger?-&gt;debug('Discogs search returned no results', ['artist' =&gt; $artista, 'title' =&gt; $titulo]);&#10;                return null;&#10;            }&#10;&#10;            $releaseId = $data['results'][0]['id'];&#10;            return $this-&gt;fetchRelease($releaseId);&#10;&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger?-&gt;error('Error fetching release data from Discogs', ['exception' =&gt; $e-&gt;getMessage(), 'artist' =&gt; $artista, 'title' =&gt; $titulo, 'discogsId' =&gt; $discogsId]);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene los detalles completos de un release por su ID de Discogs.&#10;     */&#10;    public function fetchRelease(int $id, string $type = 'releases'): ?array&#10;    {&#10;        try {&#10;            $response = $this-&gt;client-&gt;request('GET', self::BASE_URL . '/' . $type . '/' . $id, [&#10;                'headers' =&gt; $this-&gt;headers(),&#10;            ]);&#10;&#10;            return $response-&gt;toArray();&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger?-&gt;error('Error fetching release from Discogs', ['exception' =&gt; $e-&gt;getMessage(), 'discogsId' =&gt; $id]);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extrae la URL de la imagen principal de un release.&#10;     * Prioriza 'primary' image, o la primera disponible.&#10;     */&#10;    public function getImageUrl(?array $releaseData): ?string&#10;    {&#10;        if (!$releaseData || empty($releaseData['images'])) {&#10;            $this-&gt;logger?-&gt;debug('No images found in release data', ['releaseData_keys' =&gt; $releaseData ? array_keys($releaseData) : null]);&#10;            return null;&#10;        }&#10;&#10;        // Buscar imagen primaria&#10;        foreach ($releaseData['images'] as $image) {&#10;            if (($image['type'] ?? '') === 'primary' &amp;&amp; !empty($image['uri'])) {&#10;                return $image['uri'];&#10;            }&#10;        }&#10;&#10;        // Si no hay primaria, devolver la primera imagen&#10;        $uri = $releaseData['images'][0]['uri'] ?? null;&#10;        if ($uri) {&#10;            return $uri;&#10;        }&#10;&#10;        $this-&gt;logger?-&gt;debug('Images array exists but no uri found', ['images' =&gt; $releaseData['images']]);&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Busca lanzamientos por texto libre (para el buscador general).&#10;     */&#10;    public function search(string $query, int $perPage = 20, int $page = 1): array&#10;    {&#10;        try {&#10;            $response = $this-&gt;client-&gt;request('GET', self::BASE_URL . '/database/search', [&#10;                'headers' =&gt; $this-&gt;headers(),&#10;                'query'   =&gt; [&#10;                    'q'        =&gt; $query,&#10;                    'type'     =&gt; 'release',&#10;                    'per_page' =&gt; $perPage,&#10;                    'page'     =&gt; $page,&#10;                ],&#10;            ]);&#10;&#10;            return $response-&gt;toArray();&#10;        } catch (\Throwable $e) {&#10;            $this-&gt;logger?-&gt;error('Discogs search error', ['exception' =&gt; $e-&gt;getMessage(), 'query' =&gt; $query]);&#10;            return ['results' =&gt; [], 'pagination' =&gt; []];&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Descarga una imagen de Discogs y la guarda en public/img/vinilos/.&#10;     * Si ya existe el archivo local, no la vuelve a descargar.&#10;     * Devuelve la ruta relativa pública (ej: /img/vinilos/discogs_24047.jpeg) o null.&#10;     */&#10;    public function downloadImage(string $url, string $filename): ?string&#10;    {&#10;        $dir = $this-&gt;projectDir . '/public/img/vinilos/';&#10;&#10;        if (!is_dir($dir)) {&#10;            mkdir($dir, 0775, true);&#10;        }&#10;&#10;        $localPath = $dir . $filename;&#10;&#10;        // Si ya existe, no descargar de nuevo&#10;        if (file_exists($localPath)) {&#10;            return '/img/vinilos/' . $filename;&#10;        }&#10;&#10;        $context = stream_context_create([&#10;            'http' =&gt; [&#10;                'header'  =&gt; &quot;User-Agent: SpinSoundApp/1.0\r\nAuthorization: Discogs token=&quot; . $this-&gt;token . &quot;\r\n&quot;,&#10;                'timeout' =&gt; 15,&#10;            ],&#10;        ]);&#10;&#10;        $imageData = @file_get_contents($url, false, $context);&#10;&#10;        if ($imageData === false) {&#10;            $this-&gt;logger?-&gt;warning('No se pudo descargar la imagen', ['url' =&gt; $url]);&#10;            return null;&#10;        }&#10;&#10;        file_put_contents($localPath, $imageData);&#10;        $this-&gt;logger?-&gt;info('Imagen guardada localmente', ['path' =&gt; $localPath]);&#10;&#10;        return '/img/vinilos/' . $filename;&#10;    }&#10;&#10;    public function getProjectDir(): string&#10;    {&#10;        return $this-&gt;projectDir;&#10;    }&#10;&#10;    private function headers(): array&#10;    {&#10;        $headers = [&#10;            'User-Agent' =&gt; 'SpinSoundApp/1.0 +https://spinsound.com',&#10;        ];&#10;&#10;        if ($this-&gt;token) {&#10;            $headers['Authorization'] = 'Discogs token=' . $this-&gt;token;&#10;        } else {&#10;            $this-&gt;logger?-&gt;warning('Discogs token is empty. API requests may be rate-limited or blocked. Set DISCOGS_TOKEN in .env.');&#10;        }&#10;&#10;        return $headers;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>